<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniBoard Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out;
        }
    </style>
</head>
<body class="m-0 p-0">
    <div id="app"></div>

    <script>
        // ========== Constants ==========
        const PIXELS_PER_MM = 8;
        const DEFAULT_PITCH = 2.54;
        const DEFAULT_GRID_SIZE = DEFAULT_PITCH * PIXELS_PER_MM;
        const DEFAULT_BOARD_WIDTH = 40;
        const DEFAULT_BOARD_HEIGHT = 30;
        const HOLE_RADIUS = 2;

        const COMPONENT_PREFIXES = {
            resistor: 'R',
            capacitor: 'C',
            led: 'D',
            ic_dip: 'U',
            jumper: 'J',
            general: 'P'
        };

        const COMPONENT_DEFINITIONS = {
            RESISTOR: {
                id: 'resistor',
                name: 'ÊäµÊäó',
                defaultWidth: 3,
                defaultHeight: 1
            },
            CAPACITOR: {
                id: 'capacitor',
                name: '„Ç≥„É≥„Éá„É≥„Çµ',
                defaultWidth: 2,
                defaultHeight: 1
            },
            LED: {
                id: 'led',
                name: 'LED',
                defaultWidth: 1,
                defaultHeight: 1
            },
            IC_DIP: {
                id: 'ic_dip',
                name: 'IC (DIP)',
                defaultWidth: 4,
                defaultHeight: 4
            },
            GENERAL: {
                id: 'general',
                name: 'Ê±éÁî®ÈÉ®ÂìÅ',
                defaultWidth: 3,
                defaultHeight: 1
            },
            JUMPER: {
                id: 'jumper',
                name: '„Éî„É≥„Éò„ÉÉ„ÉÄ',
                defaultWidth: 4,
                defaultHeight: 1
            }
        };

        const WIRE_COLORS = [
            { name: 'Ëµ§', value: '#ef4444' },
            { name: 'Èªí', value: '#1f2937' },
            { name: 'Èùí', value: '#3b82f6' },
            { name: 'ÈªÑ', value: '#eab308' },
            { name: 'Á∑ë', value: '#22c55e' },
            { name: 'ÁôΩ', value: '#f3f4f6' }
        ];

        // ========== State ==========
        const state = {
            boardConfig: {
                width: DEFAULT_BOARD_WIDTH,
                height: DEFAULT_BOARD_HEIGHT,
                pitch: DEFAULT_PITCH,
                gridSize: DEFAULT_GRID_SIZE
            },
            components: [],
            wires: [],
            selectedTool: 'select',
            wireColor: WIRE_COLORS[0].value,
            scale: 1.5,
            currentWireStart: null,
            selectedItem: null,
            showLabels: true,
            viewSide: 'front',
            componentSizes: Object.values(COMPONENT_DEFINITIONS).reduce((acc, def) => {
                acc[def.id] = { width: def.defaultWidth, height: def.defaultHeight };
                return acc;
            }, {}),
            activeSize: { width: 0, height: 0 },
            draggedComponent: null,
            hoveredGrid: null
        };

        // ========== Helper Functions ==========
        function createSVGElement(type, attributes = {}) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', type);
            Object.keys(attributes).forEach(key => {
                element.setAttribute(key, attributes[key]);
            });
            return element;
        }

        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        function getGridCoords(clientX, clientY) {
            const svg = document.getElementById('board-svg');
            if (!svg) return { x: 0, y: 0 };
            const rect = svg.getBoundingClientRect();

            let x = (clientX - rect.left) / state.scale;
            const y = (clientY - rect.top) / state.scale;

            const totalBoardWidth = state.boardConfig.width * state.boardConfig.gridSize + state.boardConfig.gridSize;

            if (state.viewSide === 'back') {
                x = totalBoardWidth - x;
            }

            return {
                x: Math.round(x / state.boardConfig.gridSize),
                y: Math.round(y / state.boardConfig.gridSize)
            };
        }

        function getComponentPinOffsets(type, width, height) {
            const pins = [];
            if (type === 'resistor' || type === 'capacitor') {
                pins.push({ x: 0, y: 0 });
                pins.push({ x: width - 1, y: 0 });
            } else if (type === 'led') {
                pins.push({ x: 0, y: 0 });
            } else if (type === 'ic_dip') {
                for (let x = 0; x < width; x++) {
                    pins.push({ x, y: 0 });
                    pins.push({ x, y: height - 1 });
                }
            } else if (type === 'jumper' || type === 'general') {
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        pins.push({ x, y });
                    }
                }
            }
            return pins;
        }

        // ========== Render Functions ==========
        function renderResistor(g, w, h, gridSize, gridW) {
            const padLeft = gridSize / 2;
            const padRight = w - gridSize / 2;

            if (gridW < 2) {
                const circle = createSVGElement('circle', {
                    cx: w / 2,
                    cy: h / 2,
                    r: gridSize / 4,
                    fill: '#e5e7eb',
                    stroke: '#4b5563'
                });
                const line = createSVGElement('line', {
                    x1: w / 2,
                    y1: gridSize / 4,
                    x2: w / 2,
                    y2: h - gridSize / 4,
                    stroke: 'brown',
                    'stroke-width': 2
                });
                g.appendChild(circle);
                g.appendChild(line);
                return;
            }

            const innerDist = padRight - padLeft;
            const bodyWidth = innerDist * 0.6;
            const leadLen = (innerDist - bodyWidth) / 2;
            const bodyStart = padLeft + leadLen;
            const bodyEnd = padRight - leadLen;

            g.appendChild(createSVGElement('line', {
                x1: padLeft, y1: gridSize / 2, x2: bodyStart, y2: gridSize / 2,
                stroke: '#ccc', 'stroke-width': 2
            }));
            g.appendChild(createSVGElement('circle', {
                cx: padLeft, cy: gridSize / 2, r: 2, fill: '#9ca3af'
            }));

            g.appendChild(createSVGElement('line', {
                x1: bodyEnd, y1: gridSize / 2, x2: padRight, y2: gridSize / 2,
                stroke: '#ccc', 'stroke-width': 2
            }));
            g.appendChild(createSVGElement('circle', {
                cx: padRight, cy: gridSize / 2, r: 2, fill: '#9ca3af'
            }));

            g.appendChild(createSVGElement('rect', {
                x: bodyStart, y: gridSize / 4, width: bodyWidth, height: gridSize / 2,
                fill: '#e5e7eb', stroke: '#4b5563', rx: 3
            }));

            const colors = [
                { x: bodyStart + bodyWidth * 0.3, color: 'brown' },
                { x: bodyStart + bodyWidth * 0.5, color: 'red' },
                { x: bodyStart + bodyWidth * 0.7, color: 'gold' }
            ];
            colors.forEach(c => {
                g.appendChild(createSVGElement('line', {
                    x1: c.x, y1: gridSize / 4, x2: c.x, y2: gridSize * 0.75,
                    stroke: c.color, 'stroke-width': 2
                }));
            });
        }

        function renderCapacitor(g, w, h, gridSize) {
            const padLeft = gridSize / 2;
            const padRight = w - gridSize / 2;
            const gap = Math.min(gridSize * 0.4, (padRight - padLeft) * 0.4);

            g.appendChild(createSVGElement('line', {
                x1: padLeft, y1: gridSize / 2, x2: w / 2 - gap, y2: gridSize / 2,
                stroke: '#ccc', 'stroke-width': 2
            }));
            g.appendChild(createSVGElement('circle', {
                cx: padLeft, cy: gridSize / 2, r: 2, fill: '#9ca3af'
            }));

            g.appendChild(createSVGElement('line', {
                x1: w / 2 + gap, y1: gridSize / 2, x2: padRight, y2: gridSize / 2,
                stroke: '#ccc', 'stroke-width': 2
            }));
            g.appendChild(createSVGElement('circle', {
                cx: padRight, cy: gridSize / 2, r: 2, fill: '#9ca3af'
            }));

            g.appendChild(createSVGElement('circle', {
                cx: w / 2, cy: gridSize / 2,
                r: Math.min(gridSize / 2.5, (padRight - padLeft) / 2),
                fill: '#3b82f6', stroke: '#1d4ed8'
            }));
        }

        function renderLED(g, w, h, gridSize) {
            const radius = Math.min(w, h) / 2.2;
            const innerRadius = radius * 0.7;
            const cx = w / 2;
            const cy = h / 2;

            g.appendChild(createSVGElement('circle', {
                cx, cy, r: radius,
                fill: 'rgba(239, 68, 68, 0.2)', stroke: '#ef4444'
            }));
            g.appendChild(createSVGElement('circle', {
                cx, cy, r: innerRadius, fill: '#ef4444'
            }));
            g.appendChild(createSVGElement('line', {
                x1: cx - 2, y1: cy - innerRadius, x2: cx - 2, y2: cy + innerRadius,
                stroke: 'white', 'stroke-width': 1
            }));
            g.appendChild(createSVGElement('line', {
                x1: cx + 2, y1: cy, x2: cx + 2, y2: cy + innerRadius,
                stroke: 'white', 'stroke-width': 1
            }));
            g.appendChild(createSVGElement('line', {
                x1: cx, y1: cy - innerRadius, x2: cx + innerRadius, y2: cy,
                stroke: 'white', 'stroke-width': 1
            }));
        }

        function renderICDIP(g, w, h, gridSize, gridW) {
            const topPinCenterY = gridSize / 2;
            const bottomPinCenterY = h - gridSize / 2;
            const pinH = gridSize / 2;
            const pinW = 4;
            const bodyX = 0;
            const bodyY = topPinCenterY + 2;
            const bodyW = w;
            const bodyH = bottomPinCenterY - 2 - bodyY;

            for (let i = 0; i < gridW; i++) {
                const pinCenterX = gridSize * (i + 0.5);

                g.appendChild(createSVGElement('rect', {
                    x: pinCenterX - pinW / 2, y: topPinCenterY - pinH / 2,
                    width: pinW, height: pinH, fill: '#9ca3af'
                }));
                g.appendChild(createSVGElement('circle', {
                    cx: pinCenterX, cy: topPinCenterY, r: 1.5, fill: '#6b7280'
                }));

                g.appendChild(createSVGElement('rect', {
                    x: pinCenterX - pinW / 2, y: bottomPinCenterY - pinH / 2,
                    width: pinW, height: pinH, fill: '#9ca3af'
                }));
                g.appendChild(createSVGElement('circle', {
                    cx: pinCenterX, cy: bottomPinCenterY, r: 1.5, fill: '#6b7280'
                }));
            }

            g.appendChild(createSVGElement('rect', {
                x: bodyX, y: bodyY, width: bodyW, height: bodyH,
                fill: '#1f2937', stroke: 'none', rx: 2
            }));

            const notchPath = `M ${bodyX} ${h / 2 - 5} Q ${bodyX + 5} ${h / 2} ${bodyX} ${h / 2 + 5}`;
            g.appendChild(createSVGElement('path', {
                d: notchPath, fill: '#374151', stroke: 'none'
            }));

            if (bodyW > 20 && bodyH > 10) {
                const text = createSVGElement('text', {
                    x: w / 2, y: h / 2,
                    'text-anchor': 'middle',
                    'dominant-baseline': 'middle',
                    fill: 'white',
                    'font-size': '8',
                    'pointer-events': 'none'
                });
                text.textContent = 'IC';
                g.appendChild(text);
            }
        }

        function renderGeneral(g, w, h, gridSize, gridW, gridH) {
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    const cx = x * gridSize + gridSize / 2;
                    const cy = y * gridSize + gridSize / 2;
                    g.appendChild(createSVGElement('circle', {
                        cx, cy, r: 3,
                        fill: '#9ca3af', stroke: '#4b5563', 'stroke-width': 1
                    }));
                }
            }

            const padding = 2;
            g.appendChild(createSVGElement('rect', {
                x: padding, y: padding,
                width: w - padding * 2, height: h - padding * 2,
                fill: '#8b5cf6', 'fill-opacity': 0.4,
                stroke: '#7c3aed', 'stroke-width': 2, rx: 4
            }));
        }

        function renderJumper(g, w, h, gridSize, gridW, gridH) {
            for (let y = 0; y < gridH; y++) {
                for (let x = 0; x < gridW; x++) {
                    g.appendChild(createSVGElement('rect', {
                        x: x * gridSize + 2, y: y * gridSize + 2,
                        width: gridSize - 4, height: gridSize - 4,
                        fill: 'gold', stroke: 'orange', 'stroke-width': 1
                    }));
                }
            }
        }

        function renderComponent(g, comp, def, gridSize) {
            const w = comp.width * gridSize;
            const h = comp.height * gridSize;

            if (comp.type === 'resistor') renderResistor(g, w, h, gridSize, comp.width);
            else if (comp.type === 'capacitor') renderCapacitor(g, w, h, gridSize);
            else if (comp.type === 'led') renderLED(g, w, h, gridSize);
            else if (comp.type === 'ic_dip') renderICDIP(g, w, h, gridSize, comp.width);
            else if (comp.type === 'general') renderGeneral(g, w, h, gridSize, comp.width, comp.height);
            else if (comp.type === 'jumper') renderJumper(g, w, h, gridSize, comp.width, comp.height);
        }

        // ========== SVG Rendering ==========
        function renderSVG() {
            const svg = document.getElementById('board-svg');
            if (!svg) return;

            while (svg.children.length > 1) {
                svg.removeChild(svg.lastChild);
            }

            const totalBoardWidth = state.boardConfig.width * state.boardConfig.gridSize + state.boardConfig.gridSize;
            const totalBoardHeight = state.boardConfig.height * state.boardConfig.gridSize + state.boardConfig.gridSize;

            svg.setAttribute('width', totalBoardWidth);
            svg.setAttribute('height', totalBoardHeight);

            const mainGroup = createSVGElement('g', {
                transform: state.viewSide === 'back' ? `scale(-1, 1) translate(-${totalBoardWidth}, 0)` : ''
            });

            const holesGroup = createSVGElement('g');
            for (let y = 0; y <= state.boardConfig.height; y++) {
                for (let x = 0; x <= state.boardConfig.width; x++) {
                    holesGroup.appendChild(createSVGElement('circle', {
                        cx: x * state.boardConfig.gridSize,
                        cy: y * state.boardConfig.gridSize,
                        r: HOLE_RADIUS,
                        fill: '#1f2937',
                        opacity: 0.3,
                        style: 'pointer-events: none'
                    }));
                }
            }
            mainGroup.appendChild(holesGroup);

            const wiresGroup = createSVGElement('g', { class: 'wires' });
            state.wires.forEach(wire => {
                const isSelected = state.selectedItem?.type === 'wire' && state.selectedItem.id === wire.id;

                const wireGroup = createSVGElement('g');
                wireGroup.classList.add('cursor-pointer', 'hover:opacity-80');

                wireGroup.appendChild(createSVGElement('line', {
                    x1: wire.startX * state.boardConfig.gridSize,
                    y1: wire.startY * state.boardConfig.gridSize,
                    x2: wire.endX * state.boardConfig.gridSize,
                    y2: wire.endY * state.boardConfig.gridSize,
                    stroke: 'transparent',
                    'stroke-width': state.boardConfig.gridSize / 2
                }));

                wireGroup.appendChild(createSVGElement('line', {
                    x1: wire.startX * state.boardConfig.gridSize,
                    y1: wire.startY * state.boardConfig.gridSize,
                    x2: wire.endX * state.boardConfig.gridSize,
                    y2: wire.endY * state.boardConfig.gridSize,
                    stroke: wire.color,
                    'stroke-width': Math.max(2, state.boardConfig.gridSize * 0.15),
                    'stroke-linecap': 'round',
                    opacity: 0.9
                }));

                if (isSelected) {
                    wireGroup.appendChild(createSVGElement('line', {
                        x1: wire.startX * state.boardConfig.gridSize,
                        y1: wire.startY * state.boardConfig.gridSize,
                        x2: wire.endX * state.boardConfig.gridSize,
                        y2: wire.endY * state.boardConfig.gridSize,
                        stroke: 'white',
                        'stroke-width': 1,
                        'stroke-dasharray': '2,2'
                    }));
                }

                wireGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.selectedItem = { type: 'wire', id: wire.id };
                    render();
                });

                wiresGroup.appendChild(wireGroup);
            });

            if (state.selectedTool === 'wire' && state.hoveredGrid) {
                const previewGroup = createSVGElement('g');
                previewGroup.style.pointerEvents = 'none';

                previewGroup.appendChild(createSVGElement('circle', {
                    cx: state.hoveredGrid.x * state.boardConfig.gridSize,
                    cy: state.hoveredGrid.y * state.boardConfig.gridSize,
                    r: state.boardConfig.gridSize / 2.5,
                    fill: state.wireColor,
                    opacity: 0.3
                }));
                previewGroup.appendChild(createSVGElement('circle', {
                    cx: state.hoveredGrid.x * state.boardConfig.gridSize,
                    cy: state.hoveredGrid.y * state.boardConfig.gridSize,
                    r: 2,
                    fill: 'white'
                }));

                wiresGroup.appendChild(previewGroup);
            }

            if (state.selectedTool === 'wire' && state.currentWireStart && state.hoveredGrid) {
                const inProgressGroup = createSVGElement('g');
                inProgressGroup.style.pointerEvents = 'none';

                inProgressGroup.appendChild(createSVGElement('line', {
                    x1: state.currentWireStart.x * state.boardConfig.gridSize,
                    y1: state.currentWireStart.y * state.boardConfig.gridSize,
                    x2: state.hoveredGrid.x * state.boardConfig.gridSize,
                    y2: state.hoveredGrid.y * state.boardConfig.gridSize,
                    stroke: state.wireColor,
                    'stroke-width': Math.max(2, state.boardConfig.gridSize * 0.15),
                    'stroke-linecap': 'round',
                    opacity: 0.6,
                    'stroke-dasharray': '4,4'
                }));
                inProgressGroup.appendChild(createSVGElement('circle', {
                    cx: state.currentWireStart.x * state.boardConfig.gridSize,
                    cy: state.currentWireStart.y * state.boardConfig.gridSize,
                    r: 4,
                    fill: state.wireColor
                }));

                wiresGroup.appendChild(inProgressGroup);
            }

            mainGroup.appendChild(wiresGroup);

            const componentsGroup = createSVGElement('g', { class: 'components' });
            componentsGroup.style.opacity = state.viewSide === 'back' ? 0.3 : 1;

            state.components.forEach(comp => {
                const def = Object.values(COMPONENT_DEFINITIONS).find(t => t.id === comp.type);
                const isSelected = state.selectedItem?.type === 'component' && state.selectedItem.id === comp.id;

                const offsetX = -state.boardConfig.gridSize / 2;
                const offsetY = -state.boardConfig.gridSize / 2;
                const w = comp.width * state.boardConfig.gridSize;
                const h = comp.height * state.boardConfig.gridSize;

                const compGroup = createSVGElement('g', {
                    transform: `translate(${comp.x + offsetX}, ${comp.y + offsetY}) rotate(${comp.rotation}, ${state.boardConfig.gridSize / 2}, ${state.boardConfig.gridSize / 2})`
                });
                compGroup.classList.add('cursor-move');
                if (isSelected) {
                    compGroup.style.filter = 'drop-shadow(0 0 2px white)';
                }

                if (isSelected) {
                    compGroup.appendChild(createSVGElement('rect', {
                        x: -2, y: -2, width: w + 4, height: h + 4,
                        fill: 'none', stroke: '#6366f1', 'stroke-width': 1,
                        'stroke-dasharray': '2,2', rx: 2
                    }));
                }

                const renderGroup = createSVGElement('g');
                renderComponent(renderGroup, comp, def, state.boardConfig.gridSize);
                compGroup.appendChild(renderGroup);

                if (state.showLabels) {
                    const labelGroup = createSVGElement('g', {
                        transform: `rotate(${-comp.rotation}, ${w / 2}, ${h / 2})`
                    });

                    const labelTransformGroup = createSVGElement('g', {
                        transform: `translate(${w / 2}, 0)`
                    });

                    if (state.viewSide === 'back') {
                        labelTransformGroup.setAttribute('transform', `translate(${w / 2}, 0) scale(-1, 1)`);
                    }

                    const nameText = createSVGElement('text', {
                        x: 0, y: -5,
                        'text-anchor': 'middle',
                        'font-size': state.boardConfig.gridSize * 0.6,
                        fill: 'white',
                        style: 'text-shadow: 0px 0px 2px rgba(0,0,0,0.8); pointer-events: none; user-select: none; font-weight: bold;'
                    });
                    nameText.textContent = comp.name;
                    labelTransformGroup.appendChild(nameText);

                    const valueText = createSVGElement('text', {
                        x: 0, y: h + state.boardConfig.gridSize * 0.6,
                        'text-anchor': 'middle',
                        'font-size': state.boardConfig.gridSize * 0.5,
                        fill: '#ddd',
                        style: 'text-shadow: 0px 0px 2px rgba(0,0,0,0.8); pointer-events: none; user-select: none;'
                    });
                    valueText.textContent = comp.value || '';
                    labelTransformGroup.appendChild(valueText);

                    labelGroup.appendChild(labelTransformGroup);
                    compGroup.appendChild(labelGroup);
                }

                compGroup.addEventListener('mousedown', (e) => handleComponentDragStart(e, comp.id));

                componentsGroup.appendChild(compGroup);
            });

            mainGroup.appendChild(componentsGroup);
            svg.appendChild(mainGroup);
        }

        // ========== UI Rendering ==========
        function renderBoardUI() {
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="flex h-screen bg-gray-100 font-sans text-gray-800 overflow-hidden">
                    <!-- Sidebar -->
                    <div class="w-72 bg-white border-r border-gray-200 flex flex-col shadow-sm z-10">
                        <div class="p-4 border-b border-gray-200">
                            <h1 class="text-lg font-bold text-indigo-600">
                                üî≤ UniBoard Designer
                            </h1>
                        </div>

                        <div class="flex-1 overflow-y-auto p-4 space-y-6">
                            <!-- Board Config -->
                            <div class="bg-gray-50 p-3 rounded border border-gray-200">
                                <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">‚öôÔ∏è Âü∫ÊùøË®≠ÂÆö</h3>
                                <div class="grid grid-cols-2 gap-2 text-xs">
                                    <label class="flex flex-col">
                                        <span class="mb-1 text-gray-600">Ê®™Á©¥Êï∞</span>
                                        <input 
                                            type="number" 
                                            id="boardWidth"
                                            value="${state.boardConfig.width}"
                                            class="p-1 border rounded"
                                            min="5" max="100"
                                        />
                                    </label>
                                    <label class="flex flex-col">
                                        <span class="mb-1 text-gray-600">Á∏¶Á©¥Êï∞</span>
                                        <input 
                                            type="number" 
                                            id="boardHeight"
                                            value="${state.boardConfig.height}"
                                            class="p-1 border rounded"
                                            min="5" max="100"
                                        />
                                    </label>
                                    <label class="flex flex-col col-span-2">
                                        <span class="mb-1 text-gray-600">„Éî„ÉÉ„ÉÅ (mm)</span>
                                        <input 
                                            type="number" 
                                            id="boardPitch"
                                            value="${state.boardConfig.pitch}"
                                            class="p-1 border rounded"
                                            step="0.01"
                                            min="0.1"
                                            max="10"
                                        />
                                    </label>
                                </div>
                            </div>

                            <!-- Display Settings -->
                            <div>
                                <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">üìù Ë°®Á§∫Ë®≠ÂÆö</h3>
                                <button 
                                    id="toggleLabels"
                                    class="flex items-center gap-2 text-sm p-2 hover:bg-gray-50 rounded w-full border border-transparent hover:border-gray-200"
                                >
                                    ${state.showLabels ? '‚úîÔ∏è' : '‚òê'} ÈÉ®ÂìÅ„É©„Éô„É´„ÇíË°®Á§∫
                                </button>
                            </div>

                            <!-- Tools -->
                            <div>
                                <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">üõ†Ô∏è „ÉÑ„Éº„É´</h3>
                                <div class="grid grid-cols-2 gap-2">
                                    <button
                                        id="selectTool"
                                        class="flex items-center gap-2 p-2 rounded text-sm ${state.selectedTool === 'select' ? 'bg-indigo-100 text-indigo-700 ring-1 ring-indigo-500' : 'hover:bg-gray-100'}"
                                    >
                                        üëÜ ÈÅ∏Êäû„ÉªÁßªÂãï
                                    </button>
                                    <button
                                        id="wireTool"
                                        class="flex items-center gap-2 p-2 rounded text-sm ${state.selectedTool === 'wire' ? 'bg-indigo-100 text-indigo-700 ring-1 ring-indigo-500' : 'hover:bg-gray-100'}"
                                    >
                                        üîå ÈÖçÁ∑ö„É¢„Éº„Éâ
                                    </button>
                                </div>
                            </div>

                            <!-- Selected Component -->
                            ${state.selectedItem?.type === 'component' ? `
                                <div class="bg-indigo-50 p-3 rounded border border-indigo-200 border-l-4 border-l-indigo-500 animate-fade-in">
                                    <h3 class="text-xs font-semibold text-indigo-700 uppercase tracking-wider mb-2">
                                        ÈÅ∏ÊäûÈÉ®ÂìÅ: ${COMPONENT_DEFINITIONS[state.selectedItem.componentType]?.name || ''}
                                    </h3>
                                    <div class="space-y-2 text-xs">
                                        <label class="block">
                                            <span class="text-gray-600 block mb-1">ÈÉ®ÂìÅÂêç (‰æã: R1)</span>
                                            <input 
                                                type="text" 
                                                id="componentName"
                                                value="${state.components.find(c => c.id === state.selectedItem.id)?.name || ''}"
                                                class="w-full p-1 border rounded" 
                                            />
                                        </label>
                                        <label class="block">
                                            <span class="text-gray-600 block mb-1">Ë™¨Êòé (‰æã: 10kŒ©)</span>
                                            <input 
                                                type="text" 
                                                id="componentValue"
                                                value="${state.components.find(c => c.id === state.selectedItem.id)?.value || ''}"
                                                class="w-full p-1 border rounded" 
                                            />
                                        </label>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Component Size -->
                            ${state.selectedTool !== 'select' && state.selectedTool !== 'wire' ? `
                                <div class="bg-yellow-50 p-3 rounded border border-yellow-200 animate-fade-in">
                                    <h3 class="text-xs font-semibold text-yellow-700 uppercase tracking-wider mb-2">
                                        ÂàùÊúü„Çµ„Ç§„Ç∫Ë®≠ÂÆö
                                    </h3>
                                    <div class="grid grid-cols-2 gap-2 text-xs">
                                        <label>
                                            ÂπÖÔºà„Éû„ÇπÔºâ: 
                                            <input 
                                                type="number" 
                                                id="sizeWidth"
                                                min="1" 
                                                max="40" 
                                                value="${state.activeSize.width}"
                                                class="w-12 p-1 border rounded ml-1" 
                                            />
                                        </label>
                                        <label>
                                            È´ò„ÅïÔºà„Éû„ÇπÔºâ: 
                                            <input 
                                                type="number" 
                                                id="sizeHeight"
                                                min="1" 
                                                max="40" 
                                                value="${state.activeSize.height}"
                                                class="w-12 p-1 border rounded ml-1" 
                                            />
                                        </label>
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Wire Colors -->
                            ${state.selectedTool === 'wire' ? `
                                <div class="animate-fade-in">
                                    <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">ÈÖçÁ∑öËâ≤</h3>
                                    <div class="flex flex-wrap gap-2">
                                        ${WIRE_COLORS.map(c => `
                                            <button
                                                class="w-6 h-6 rounded-full border border-gray-300 shadow-sm ${state.wireColor === c.value ? 'ring-2 ring-offset-1 ring-indigo-500' : ''}"
                                                style="background-color: ${c.value}"
                                                title="${c.name}"
                                                onclick="state.wireColor = '${c.value}'; render();"
                                            ></button>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}

                            <!-- Component Palette -->
                            <div>
                                <h3 class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">ÈÉ®ÂìÅ„É™„Çπ„Éà</h3>
                                <div class="space-y-1">
                                    ${Object.values(COMPONENT_DEFINITIONS).map(comp => {
                                        const icon = comp.id === 'resistor' ? 'üîß' : 
                                                   comp.id === 'led' ? 'üí°' : 
                                                   comp.id === 'ic_dip' ? 'üîå' : 
                                                   comp.id === 'capacitor' ? '‚óØ' :
                                                   comp.id === 'general' ? 'üü™' :
                                                   'üìç';
                                        return `
                                            <button
                                                class="w-full flex items-center gap-3 p-2 rounded text-sm text-left transition-colors ${state.selectedTool === comp.id ? 'bg-indigo-100 text-indigo-700 ring-1 ring-indigo-500' : 'hover:bg-gray-50'}"
                                                onclick="selectTool('${comp.id}'); render();"
                                            >
                                                <div class="text-lg">${icon}</div>
                                                <div class="flex flex-col">
                                                    <span>${comp.name}</span>
                                                    <span class="text-[10px] text-gray-400">
                                                        ${state.componentSizes[comp.id]?.width || comp.defaultWidth}x${state.componentSizes[comp.id]?.height || comp.defaultHeight}
                                                    </span>
                                                </div>
                                            </button>
                                        `;
                                    }).join('')}
                                </div>
                            </div>

                            <div class="p-3 bg-blue-50 rounded text-xs text-blue-700 space-y-1">
                                <p><strong>R „Ç≠„Éº:</strong> ÈÅ∏ÊäûÈÉ®ÂìÅ„ÇíÂõûËª¢</p>
                                <p><strong>Delete:</strong> ÈÅ∏ÊäûÈ†ÖÁõÆ„ÇíÂâäÈô§</p>
                                <p><strong>Esc / Âè≥„ÇØ„É™„ÉÉ„ÇØ:</strong> „Ç≠„É£„É≥„Çª„É´</p>
                            </div>
                        </div>

                        <div class="p-4 border-t border-gray-200 bg-gray-50 flex gap-2">
                            <button onclick="saveDesign();" class="flex-1 flex items-center justify-center gap-1 bg-white border border-gray-300 p-2 rounded hover:bg-gray-100 text-sm">
                                üíæ ‰øùÂ≠ò
                            </button>
                            <label class="flex-1 flex items-center justify-center gap-1 bg-white border border-gray-300 p-2 rounded hover:bg-gray-100 text-sm cursor-pointer">
                                üìÇ Èñã„Åè
                                <input type="file" accept=".json" onchange="loadDesign(event);" class="hidden" />
                            </label>
                        </div>
                    </div>

                    <!-- Main Area -->
                    <div class="flex-1 flex flex-col relative bg-gray-200 overflow-hidden">
                        <!-- Top Toolbar -->
                        <div class="absolute top-4 left-4 right-4 flex justify-between pointer-events-none z-10">
                            <div class="bg-white/90 backdrop-blur shadow rounded-lg p-1 flex gap-1 pointer-events-auto">
                                <button onclick="state.scale = Math.max(0.5, state.scale - 0.1); render();" class="p-2 hover:bg-gray-100 rounded">‚àí</button>
                                <span class="p-2 text-sm font-mono min-w-[3rem] text-center">${Math.round(state.scale * 100)}%</span>
                                <button onclick="state.scale = Math.min(3, state.scale + 0.1); render();" class="p-2 hover:bg-gray-100 rounded">+</button>
                            </div>

                            <div class="bg-white/90 backdrop-blur shadow rounded-lg p-1 flex pointer-events-auto">
                                <button 
                                    onclick="state.viewSide = 'front'; render();"
                                    class="flex items-center gap-1 px-3 py-1 rounded text-sm ${state.viewSide === 'front' ? 'bg-indigo-100 text-indigo-700 font-bold' : 'text-gray-600 hover:bg-gray-100'}"
                                >
                                    üìÑ Ë°®Èù¢
                                </button>
                                <button 
                                    onclick="state.viewSide = 'back'; render();"
                                    class="flex items-center gap-1 px-3 py-1 rounded text-sm ${state.viewSide === 'back' ? 'bg-indigo-100 text-indigo-700 font-bold' : 'text-gray-600 hover:bg-gray-100'}"
                                >
                                    üîÑ Ë£èÈù¢
                                </button>
                            </div>

                            ${state.selectedItem ? `
                                <div class="bg-white/90 backdrop-blur shadow rounded-lg p-1 flex gap-1 pointer-events-auto animate-fade-in">
                                    ${state.selectedItem.type === 'component' ? `
                                        <button onclick="rotateSelected(); render();" class="p-2 hover:bg-gray-100 rounded text-blue-600" title="ÂõûËª¢">
                                            ‚Üª
                                        </button>
                                    ` : ''}
                                    <button onclick="deleteSelected(); render();" class="p-2 hover:bg-red-50 rounded text-red-600" title="ÂâäÈô§">
                                        üóëÔ∏è
                                    </button>
                                </div>
                            ` : ''}
                        </div>

                        <!-- Canvas Container -->
                        <div 
                            id="boardContainer"
                            class="flex-1 overflow-auto flex items-center justify-center p-8 cursor-crosshair"
                        >
                            <div 
                                id="boardScaler"
                                style="transform: scale(${state.scale}); transform-origin: center center; transition: transform 0.1s ease-out;"
                                class="bg-[#2d7a4d] shadow-2xl relative transition-all duration-300"
                            >
                                <svg
                                    id="board-svg"
                                    width="${state.boardConfig.width * state.boardConfig.gridSize + state.boardConfig.gridSize}"
                                    height="${state.boardConfig.height * state.boardConfig.gridSize + state.boardConfig.gridSize}"
                                    class="block"
                                >
                                    <defs>
                                        <pattern id="grid" width="${state.boardConfig.gridSize}" height="${state.boardConfig.gridSize}" patternUnits="userSpaceOnUse">
                                            <circle cx="${state.boardConfig.gridSize/2}" cy="${state.boardConfig.gridSize/2}" r="1" fill="#e5e7eb" opacity="0.5" />
                                        </pattern>
                                    </defs>
                                </svg>
                                
                                <div class="absolute top-1 left-1 w-2 h-2 rounded-full bg-yellow-700/50"></div>
                                <div class="absolute top-1 right-1 w-2 h-2 rounded-full bg-yellow-700/50"></div>
                                <div class="absolute bottom-1 left-1 w-2 h-2 rounded-full bg-yellow-700/50"></div>
                                <div class="absolute bottom-1 right-1 w-2 h-2 rounded-full bg-yellow-700/50"></div>
                            </div>
                        </div>

                        <!-- Status Bar -->
                        <div class="bg-white border-t p-2 text-xs text-gray-500 flex justify-between">
                            <span>Grid: ${state.boardConfig.width}x${state.boardConfig.height} (Pitch: ${state.boardConfig.pitch}mm)</span>
                            <span>Items: ${state.components.length} components, ${state.wires.length} wires</span>
                        </div>
                    </div>
                </div>
            `;

            attachEventListeners();
        }

        function attachEventListeners() {
            const boardWidth = document.getElementById('boardWidth');
            const boardHeight = document.getElementById('boardHeight');
            const boardPitch = document.getElementById('boardPitch');
            const toggleLabels = document.getElementById('toggleLabels');
            const selectToolBtn = document.getElementById('selectTool');
            const wireToolBtn = document.getElementById('wireTool');
            const componentName = document.getElementById('componentName');
            const componentValue = document.getElementById('componentValue');
            const sizeWidth = document.getElementById('sizeWidth');
            const sizeHeight = document.getElementById('sizeHeight');
            const boardContainer = document.getElementById('boardContainer');
            const svg = document.getElementById('board-svg');

            if (boardWidth) {
                boardWidth.addEventListener('change', (e) => {
                    state.boardConfig.width = Number(e.target.value);
                    render();
                });
            }

            if (boardHeight) {
                boardHeight.addEventListener('change', (e) => {
                    state.boardConfig.height = Number(e.target.value);
                    render();
                });
            }

            if (boardPitch) {
                boardPitch.addEventListener('change', (e) => {
                    const p = Math.max(0.1, Number(e.target.value));
                    state.boardConfig.pitch = p;
                    state.boardConfig.gridSize = p * PIXELS_PER_MM;
                    render();
                });
            }

            if (toggleLabels) {
                toggleLabels.addEventListener('click', () => {
                    state.showLabels = !state.showLabels;
                    render();
                });
            }

            if (selectToolBtn) {
                selectToolBtn.addEventListener('click', () => {
                    selectTool('select');
                    render();
                });
            }

            if (wireToolBtn) {
                wireToolBtn.addEventListener('click', () => {
                    selectTool('wire');
                    render();
                });
            }

            if (componentName) {
                componentName.addEventListener('change', (e) => {
                    const comp = state.components.find(c => c.id === state.selectedItem.id);
                    if (comp) comp.name = e.target.value;
                    render();
                });
            }

            if (componentValue) {
                componentValue.addEventListener('change', (e) => {
                    const comp = state.components.find(c => c.id === state.selectedItem.id);
                    if (comp) comp.value = e.target.value;
                    render();
                });
            }

            if (sizeWidth) {
                sizeWidth.addEventListener('change', (e) => {
                    const newVal = Math.max(1, Number(e.target.value));
                    state.activeSize.width = newVal;
                    state.componentSizes[state.selectedTool] = { ...state.activeSize };
                    render();
                });
            }

            if (sizeHeight) {
                sizeHeight.addEventListener('change', (e) => {
                    const newVal = Math.max(1, Number(e.target.value));
                    state.activeSize.height = newVal;
                    state.componentSizes[state.selectedTool] = { ...state.activeSize };
                    render();
                });
            }

            if (boardContainer) {
                boardContainer.addEventListener('mousedown', (e) => {
                    if (e.target === e.currentTarget || e.target.tagName === 'svg') {
                        state.selectedItem = null;
                        render();
                    }
                });
            }

            if (svg) {
                svg.addEventListener('mousedown', handleSVGMouseDown);
                svg.addEventListener('mousemove', handleSVGMouseMove);
                svg.addEventListener('mouseup', handleSVGMouseUp);
                svg.addEventListener('mouseleave', handleSVGMouseLeave);
                svg.addEventListener('contextmenu', handleRightClick);
            }
        }

        // ========== Event Handlers ==========
        function handleSVGMouseDown(e) {
            if (state.draggedComponent) return;
            if (e.button === 2) return;

            const { x, y } = getGridCoords(e.clientX, e.clientY);

            if (x < 0 || x > state.boardConfig.width || y < 0 || y > state.boardConfig.height) return;

            if (state.selectedTool === 'wire') {
                state.currentWireStart = { x, y };
            } else if (state.selectedTool === 'select') {
                // Handled by component click
            } else {
                const compDef = Object.values(COMPONENT_DEFINITIONS).find(c => c.id === state.selectedTool);
                if (compDef) {
                    addComponent(compDef, x, y);
                }
            }
            render();
        }

        function handleSVGMouseMove(e) {
            const { x, y } = getGridCoords(e.clientX, e.clientY);

            if (!state.hoveredGrid || state.hoveredGrid.x !== x || state.hoveredGrid.y !== y) {
                state.hoveredGrid = { x, y };
            }

            if (state.draggedComponent) {
                const newPixelX = (x - state.draggedComponent.offsetX) * state.boardConfig.gridSize;
                const newPixelY = (y - state.draggedComponent.offsetY) * state.boardConfig.gridSize;

                const comp = state.components.find(c => c.id === state.draggedComponent.id);
                if (comp) {
                    comp.x = newPixelX;
                    comp.y = newPixelY;
                }

                const currentGridX = Math.round(newPixelX / state.boardConfig.gridSize);
                const currentGridY = Math.round(newPixelY / state.boardConfig.gridSize);
                const deltaX = currentGridX - state.draggedComponent.initialGridX;
                const deltaY = currentGridY - state.draggedComponent.initialGridY;

                if (state.draggedComponent.connectedWires && state.draggedComponent.connectedWires.length > 0) {
                    state.draggedComponent.connectedWires.forEach(cw => {
                        const wire = state.wires.find(w => w.id === cw.id);
                        if (wire) {
                            if (cw.type === 'start') {
                                wire.startX = cw.initialX + deltaX;
                                wire.startY = cw.initialY + deltaY;
                            } else if (cw.type === 'end') {
                                wire.endX = cw.initialX + deltaX;
                                wire.endY = cw.initialY + deltaY;
                            }
                        }
                    });
                }

                render();
            } else {
                renderSVG();
            }
        }

        function handleSVGMouseUp(e) {
            if (state.selectedTool === 'wire' && state.currentWireStart) {
                const { x, y } = getGridCoords(e.clientX, e.clientY);
                if (x !== state.currentWireStart.x || y !== state.currentWireStart.y) {
                    addWire(state.currentWireStart, { x, y });
                }
                state.currentWireStart = null;
            }
            if (state.draggedComponent) {
                state.draggedComponent = null;
            }
            render();
        }

        function handleSVGMouseLeave() {
            state.hoveredGrid = null;
            renderSVG();
        }

        function handleRightClick(e) {
            e.preventDefault();
            if (state.currentWireStart || state.draggedComponent) {
                state.currentWireStart = null;
                state.draggedComponent = null;
            } else {
                selectTool('select');
            }
            render();
        }

        function handleComponentDragStart(e, id) {
            e.stopPropagation();
            if (e.button === 2) return;

            if (state.selectedTool === 'select') {
                const { x, y } = getGridCoords(e.clientX, e.clientY);
                const comp = state.components.find(c => c.id === id);
                state.selectedItem = { type: 'component', id, componentType: comp.type.toUpperCase() };

                if (comp) {
                    const pinOffsets = getComponentPinOffsets(comp.type, comp.width, comp.height);
                    const currentPins = pinOffsets.map(p => {
                        let rx = p.x, ry = p.y;
                        if (comp.rotation === 90) { rx = -p.y; ry = p.x; }
                        else if (comp.rotation === 180) { rx = -p.x; ry = -p.y; }
                        else if (comp.rotation === 270) { rx = p.y; ry = -p.x; }

                        return {
                            x: Math.round(comp.x / state.boardConfig.gridSize) + rx,
                            y: Math.round(comp.y / state.boardConfig.gridSize) + ry
                        };
                    });

                    const connectedWires = [];
                    state.wires.forEach(wire => {
                        if (currentPins.some(p => p.x === wire.startX && p.y === wire.startY)) {
                            connectedWires.push({ id: wire.id, type: 'start', initialX: wire.startX, initialY: wire.startY });
                        }
                        if (currentPins.some(p => p.x === wire.endX && p.y === wire.endY)) {
                            connectedWires.push({ id: wire.id, type: 'end', initialX: wire.endX, initialY: wire.endY });
                        }
                    });

                    state.draggedComponent = {
                        id,
                        offsetX: x - (comp.x / state.boardConfig.gridSize),
                        offsetY: y - (comp.y / state.boardConfig.gridSize),
                        initialGridX: Math.round(comp.x / state.boardConfig.gridSize),
                        initialGridY: Math.round(comp.y / state.boardConfig.gridSize),
                        connectedWires
                    };
                }
                render();
            }
        }

        // ========== State Mutations ==========
        function selectTool(toolId) {
            state.selectedTool = toolId;
            state.selectedItem = null;
            state.currentWireStart = null;

            if (toolId !== 'select' && toolId !== 'wire') {
                if (state.componentSizes[toolId]) {
                    state.activeSize = { ...state.componentSizes[toolId] };
                } else {
                    const def = Object.values(COMPONENT_DEFINITIONS).find(c => c.id === toolId);
                    if (def) {
                        state.activeSize = { width: def.defaultWidth, height: def.defaultHeight };
                    }
                }
            }
        }

        function addComponent(compDef, gridX, gridY) {
            const x = gridX * state.boardConfig.gridSize;
            const y = gridY * state.boardConfig.gridSize;

            const prefix = COMPONENT_PREFIXES[compDef.id] || 'P';
            const count = state.components.filter(c => c.type === compDef.id).length + 1;
            const name = `${prefix}${count}`;

            const newComp = {
                id: generateId(),
                type: compDef.id,
                x,
                y,
                width: state.activeSize.width || compDef.defaultWidth,
                height: state.activeSize.height || compDef.defaultHeight,
                rotation: 0,
                name,
                value: ''
            };
            state.components.push(newComp);
            state.selectedItem = { type: 'component', id: newComp.id, componentType: compDef.id.toUpperCase() };
        }

        function addWire(start, end) {
            const newWire = {
                id: generateId(),
                startX: start.x,
                startY: start.y,
                endX: end.x,
                endY: end.y,
                color: state.wireColor
            };
            state.wires.push(newWire);
        }

        function deleteSelected() {
            if (!state.selectedItem) return;
            if (state.selectedItem.type === 'component') {
                state.components = state.components.filter(c => c.id !== state.selectedItem.id);
            } else if (state.selectedItem.type === 'wire') {
                state.wires = state.wires.filter(w => w.id !== state.selectedItem.id);
            }
            state.selectedItem = null;
        }

        function rotateSelected() {
            if (state.selectedItem?.type !== 'component') return;
            const comp = state.components.find(c => c.id === state.selectedItem.id);
            if (comp) {
                comp.rotation = (comp.rotation + 90) % 360;
            }
        }

        function saveDesign() {
            const data = {
                components: state.components,
                wires: state.wires,
                boardConfig: state.boardConfig,
                componentSizes: state.componentSizes,
                showLabels: state.showLabels
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'board-design.json';
            a.click();
        }

        function loadDesign(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.boardConfig) {
                        const loadedConfig = { ...data.boardConfig };
                        if (!loadedConfig.pitch && loadedConfig.gridSize) {
                            loadedConfig.pitch = Math.round((loadedConfig.gridSize / PIXELS_PER_MM) * 100) / 100;
                        }
                        if (loadedConfig.pitch && !loadedConfig.gridSize) {
                            loadedConfig.gridSize = loadedConfig.pitch * PIXELS_PER_MM;
                        }
                        state.boardConfig = loadedConfig;
                    }
                    state.components = data.components || [];
                    state.wires = data.wires || [];
                    state.componentSizes = data.componentSizes || state.componentSizes;
                    state.showLabels = data.showLabels !== undefined ? data.showLabels : true;
                    state.selectedItem = null;
                    render();
                } catch (err) {
                    alert('„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                }
            };
            reader.readAsText(file);
        }

        // ========== Main Render ==========
        function render() {
            renderBoardUI();
            renderSVG();
        }

        // ========== Keyboard Shortcuts ==========
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelected();
                render();
            }
            if (e.key === 'r' || e.key === 'R') {
                rotateSelected();
                render();
            }
            if (e.key === 'Escape') {
                selectTool('select');
                state.draggedComponent = null;
                render();
            }
        });

        // ========== Wheel Zoom ==========
        document.addEventListener('wheel', (e) => {
            const container = document.getElementById('boardContainer');
            if (container && container.contains(e.target)) {
                e.preventDefault();
                const delta = -e.deltaY;
                const factor = 1.05;
                state.scale = delta > 0 ? state.scale * factor : state.scale / factor;
                state.scale = Math.min(Math.max(0.5, state.scale), 5);
                render();
            }
        }, { passive: false });

        // ========== Initialize ==========
        render();
    </script>
</body>
</html>
